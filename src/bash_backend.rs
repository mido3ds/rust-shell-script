use crate::parser::Expr;
use crate::parser::Stmt;
use crate::parser::Stmt::{CallCmd, DefCmd, DefFun, DefVar, Return};
use std::fs;
use std::fs::File;
use std::io::Write;
use std::os::unix::fs::OpenOptionsExt;

const INDENT: isize = 4;

macro_rules! output {
    ($fs: expr, $indent: expr, $($arg:tt)*) => {
        write!($fs, "{}", (0..$indent).map(|_| " ").collect::<String>()).expect("write error");
        writeln!($fs, $($arg)*).expect("write error");
    }
}

pub fn gen_code(stmts: &Vec<Stmt>, file: &str) {
    eprintln!("Generating bash script to {} ...", file);
    let mut file = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .mode(0o755)
        .open(file)
        .expect("create file for writing failed");

    output!(file, 0, "#!/bin/bash");
    output!(file, 0, "#");
    output!(file, 0, "# Generated by rust-shell-script");
    output!(file, 0, "#");
    output!(file, 0, ". \"${{RUNTIME:-.}}/cmd_lib.sh\"");
    output!(file, 0, "");

    for stmt in stmts {
        match stmt {
            DefFun(fun_name, parameters, body) => {
                visit_def_fun(&mut file, &fun_name, &parameters, &body)
            }
            DefCmd(cmd_name, parameters, body) => {
                visit_def_cmd(&mut file, &cmd_name, &parameters, &body)
            }
            _ => eprintln!("Not supported yet!"),
        }
    }

    output!(file, 0, "main \"$@\"");
}

fn visit_def_var(file: &mut File, indent: &mut isize, var_name: &str, var_def: &Option<Expr>) {
    if let Some(expr) = var_def {
        output!(file, *indent, "local {}", var_name);
        output!(file, *indent, "{}={}", var_name, visit_expr(expr));
    } else {
        output!(file, *indent, "local {}", var_name);
    }
}

fn visit_def_fun(file: &mut File, fun_name: &str, parameters: &Vec<String>, body: &Vec<Stmt>) {
    let mut indent = 0;
    output!(file, indent, "function {}() {{", fun_name);

    indent += INDENT;
    for (i, p) in parameters.iter().enumerate() {
        output!(file, indent, "local {}=\"${}\"", p, i + 1);
    }
    if parameters.len() > 0 {
        output!(file, 0, "");
    }

    for stmt in body {
        visit_stmt(file, &mut indent, stmt);
    }

    output!(file, 0, "}}");
    output!(file, 0, "");
}

fn visit_def_cmd(file: &mut File, fun_name: &str, parameters: &Vec<String>, body: &Vec<Stmt>) {
    let mut indent = 0;
    output!(file, indent, "{}() {{", fun_name);

    indent += INDENT;
    for (i, p) in parameters.iter().enumerate() {
        output!(file, indent, "local {}=\"${}\"", p, i + 1);
    }
    if parameters.len() > 0 {
        output!(file, 0, "");
    }

    for stmt in body {
        visit_stmt(file, &mut indent, stmt);
    }

    output!(file, 0, "}}");
    output!(file, 0, "");
}

fn visit_stmt(file: &mut File, indent: &mut isize, stmt: &Stmt) {
    match stmt {
        CallCmd(cmd, parameters) => visit_call_cmd(file, indent, &cmd, &parameters),
        Return(expr) => visit_return(file, indent, &expr),
        DefVar(var_name, var_def) => visit_def_var(file, indent, &var_name, &var_def),
        _ => {
            let stmt = format!("{:?}", stmt);
            output!(file, *indent, "{}", stmt);
        }
    }
}

fn visit_call_cmd(file: &mut File, indent: &mut isize, cmd: &str, parameters: &Vec<Expr>) {
    if parameters.len() == 0 {
        output!(file, *indent, "{}", cmd);
    } else {
        output!(file, *indent, "{} {}", cmd, visit_call(parameters));
    }
}

fn visit_call(parameters: &Vec<Expr>) -> String {
    let mut args = String::new();
    for (i, expr) in parameters.iter().enumerate() {
        if i > 0 {
            args += " ";
        }
        args += visit_expr(expr).as_ref();
    }
    args
}

fn visit_return(file: &mut File, indent: &mut isize, expr: &Expr) {
    output!(file, *indent, "return {}", visit_expr(expr));
}

fn visit_expr(expr: &Expr) -> String {
    match expr {
        Expr::LitNum(n) => format!("{}", n),
        Expr::LitStr(s) => format!("\"{}\"", s),
        Expr::Var(v) => format!("\"${{{}}}\"", v.identifier),
        Expr::CallFun(f, args) => format!("$(_call {} {})", f, visit_call(args)),
        _ => format!("{:?}", expr),
    }
}
